import { existsSync, writeFileSync, rmSync, readFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { exec } from "node:child_process";
import { DEPLOYMENTS } from "../deployments";
import Mustache from "mustache";

const [, , rawNetwork = ""] = process.argv;
const network = rawNetwork.toLowerCase();

const contracts = DEPLOYMENTS[network];
if (!contracts) {
    console.error(
        `"${network}" is not a valid network. Valid values are: ${Object.keys(DEPLOYMENTS).join(", ")}`,
    );
    process.exit(1);
}

console.log(`Generating addresses.ts file for network ${network}`);

let addressesFile =
    '// this file is automatically generated by the /scripts/generate-addresses-files.ts\n// script, do not edit this manually\n\nimport { Address, TypedMap } from "@graphprotocol/graph-ts";\n\n';
addressesFile += `export const GLP_MANAGER_ADDRESS = Address.fromString("${contracts.GlpManager.address}");\n`;
addressesFile += `export const FALP_ADDRESS = Address.fromString("${contracts.fALP}");\n`;
addressesFile += `export const FSALP_ADDRESS = Address.fromString("${contracts.fsALP}");\n`;
addressesFile += `export let TOKENIZED_VAULT_COLLATERAL = new TypedMap<Address, Address>();\n`;
for (const vault of contracts.tokenizedVaults)
    addressesFile += `TOKENIZED_VAULT_COLLATERAL.set(Address.fromString("${vault.address}"), Address.fromString("${vault.collateral}"));\n`;

try {
    const addressesFileOut = join(
        fileURLToPath(dirname(import.meta.url)),
        "../src/addresses.ts",
    );
    if (existsSync(addressesFileOut)) rmSync(addressesFileOut);
    writeFileSync(addressesFileOut, addressesFile);
    console.log("Addresses file successfully generated.");
} catch (error) {
    console.error("Error while generating addresses file", error);
    process.exit(1);
}

console.log(`Generating subgraph.yaml file for network ${network}`);

try {
    const subgraphFileOut = join(
        fileURLToPath(dirname(import.meta.url)),
        "../subgraph.yaml",
    );
    if (existsSync(subgraphFileOut)) rmSync(subgraphFileOut);
    writeFileSync(
        subgraphFileOut,
        Mustache.render(
            readFileSync(
                join(
                    fileURLToPath(dirname(import.meta.url)),
                    "../subgraph.template.mustache",
                ),
            ).toString(),
            {
                network,
                vaultAddress: contracts.Vault.address,
                vaultStartBlock: contracts.Vault.startBlock,
                glpManagerAddress: contracts.GlpManager.address,
                glpManagerStartBlock: contracts.GlpManager.startBlock,
                rewardRouterV2Address: contracts.RewardRouterV2.address,
                rewardRouterV2StartBlock: contracts.RewardRouterV2.startBlock,
                alpAddress: contracts.ALP.address,
                alpStartBlock: contracts.ALP.startBlock,
                tokenizedVaults: contracts.tokenizedVaults,
            },
        ),
    );
    console.log("Subgraph file successfully generated.");
} catch (error) {
    console.error("Error while generating subgraph file", error);
    process.exit(1);
}

exec("npm format");
