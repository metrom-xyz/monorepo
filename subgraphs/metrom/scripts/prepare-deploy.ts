import { existsSync, writeFileSync, rmSync, readFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { ADDRESS, SupportedChain } from "@metrom-xyz/contracts";
import { fileURLToPath } from "node:url";
import { exec } from "node:child_process";
import Mustache from "mustache";

const NETWORK_NAME: Record<SupportedChain, string> = {
    [SupportedChain.Holesky]: "holesky",
    [SupportedChain.BaseSepolia]: "base-sepolia",
    [SupportedChain.Sepolia]: "sepolia",

    [SupportedChain.Base]: "base",
    [SupportedChain.Mode]: "mode-mainnet",
    [SupportedChain.Mantle]: "mantle",
    [SupportedChain.Taiko]: "taiko",
    [SupportedChain.Scroll]: "scroll",
    [SupportedChain.Sonic]: "sonic",
    [SupportedChain.Form]: "form",
    [SupportedChain.Gnosis]: "gnosis",
    [SupportedChain.Telos]: "telos",
    [SupportedChain.LightLinkPhoenix]: "lightlink-phoenix",
    [SupportedChain.Sei]: "sei-mainnet",
    [SupportedChain.Swell]: "swellchain",
    [SupportedChain.Hemi]: "hemi",
    [SupportedChain.Lens]: "lens",
};

const [, , rawNetwork = ""] = process.argv;
const network = rawNetwork.toLowerCase();

const resolvedNetwork = Object.entries(NETWORK_NAME).find(([, name]) => {
    return name === network;
});
if (!resolvedNetwork) {
    console.error(
        `"${network}" is not a valid network. Valid values are: ${Object.values(NETWORK_NAME).join(", ")}`,
    );
    process.exit(1);
}

const metrom = ADDRESS[parseInt(resolvedNetwork[0]) as SupportedChain];
if (!metrom) {
    console.error(
        `"${network}" is not a valid network. Valid values are:\n\n${Object.keys(
            ADDRESS,
        )
            .map((chainId) => NETWORK_NAME[parseInt(chainId) as SupportedChain])
            .join("\n")}`,
    );
    process.exit(1);
}

console.log(`Generating addresses.ts file for network ${network}`);

let addressesFile =
    '// this file is automatically generated by the /scripts/generate-addresses-files.ts\n// script, do not edit this manually\n\nimport { Address } from "@graphprotocol/graph-ts";\n\n';
addressesFile += `export const METROM_ADDRESS = Address.fromString("${metrom.address}");\n`;

try {
    const addressesFileOut = join(
        fileURLToPath(dirname(import.meta.url)),
        "../src/addresses.ts",
    );
    if (existsSync(addressesFileOut)) rmSync(addressesFileOut);
    writeFileSync(addressesFileOut, addressesFile);
    console.log("Addresses file successfully generated.");
} catch (error) {
    console.error("Error while generating addresses file", error);
    process.exit(1);
}

console.log(`Generating subgrpah.yaml file for network ${network}`);

try {
    const pathOut = join(
        fileURLToPath(dirname(import.meta.url)),
        "../subgraph.yaml",
    );
    if (existsSync(pathOut)) rmSync(pathOut);
    writeFileSync(
        pathOut,
        Mustache.render(
            readFileSync(
                join(
                    fileURLToPath(dirname(import.meta.url)),
                    "../subgraph.template.yaml",
                ),
            ).toString(),
            {
                network:
                    resolvedNetwork[1] === "lightlink-phoenix"
                        ? "mainnet"
                        : resolvedNetwork[1],
                address: metrom.address,
                startBlock: metrom.blockCreated,
            },
        ),
    );
    console.log("subgraph.yaml file successfully generated.");
} catch (error) {
    console.error("Error while generating subgraph.yaml file", error);
    process.exit(1);
}

exec("pnpm format");
