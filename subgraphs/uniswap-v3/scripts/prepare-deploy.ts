import { existsSync, writeFileSync, rmSync, readFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { exec } from "node:child_process";
import { DEPLOYMENTS, type ChainConfig } from "../deployments";
import Mustache from "mustache";

const [, , rawNetwork = "", rawAmm = ""] = process.argv;
const network = rawNetwork.toLowerCase();
const amm = rawAmm.toLowerCase();

const networkConfig = DEPLOYMENTS[network];
if (!networkConfig) {
    console.error(
        `"${network}" is not a valid network. Valid values are: ${Object.keys(DEPLOYMENTS).join(", ")}`,
    );
    process.exit(1);
}

const contracts = networkConfig[amm];
if (!contracts) {
    console.error(
        `"${amm}" is not a valid amm for the network ${network}. Valid values are: ${Object.keys(networkConfig).join(", ")}`,
    );
    process.exit(1);
}

// Determine protocol version
const isV4 = amm.includes("v4") || "PoolManager" in contracts;
const isV3 = !isV4;

let addressesFile =
    '// this file is automatically generated by the /scripts/generate-addresses-file.ts\n// script, do not edit this manually\n\nimport { Address } from "@graphprotocol/graph-ts";\n\n';

// Add protocol version
addressesFile += `export const PROTOCOL_VERSION = "${isV4 ? "v4" : "v3"}";\n\n`;


    // V4 addresses
    const v4Contracts = contracts as ChainConfig;
    addressesFile += `export const POOL_MANAGER_ADDRESS = Address.fromString("${v4Contracts.PoolManager.address}");\n`;

    // Add placeholder addresses for v3 compatibility (set to zero)
    addressesFile += `export const FACTORY_ADDRESS = Address.zero();\n`;
    addressesFile += `export const NON_FUNGIBLE_POSITION_MANAGER_ADDRESS = Address.zero();\n`;

    if (v4Contracts.PositionManager) {
        addressesFile += `export const POSITION_MANAGER_ADDRESS = Address.fromString("${v4Contracts.PositionManager.address}");\n`;
    } else {
        addressesFile += `export const POSITION_MANAGER_ADDRESS = Address.zero();\n`;
    }


try {
    const addressesFileOut = join(
        fileURLToPath(dirname(import.meta.url)),
        "../src/addresses.ts",
    );
    if (existsSync(addressesFileOut)) rmSync(addressesFileOut);
    writeFileSync(addressesFileOut, addressesFile);
    console.log("Addresses file successfully generated.");
} catch (error) {
    console.error("Error while generating addresses file", error);
    process.exit(1);
}

let resolvedNetwork = network === "lightlink-phoenix" ? "mainnet" : network;

// Template variables
let templateVars: Record<string, unknown> = {
    network: resolvedNetwork,
    isV3: isV3,
    isV4: isV4,
};

    const v4_Contracts = contracts as ChainConfig;
    templateVars.poolManagerAddress = v4_Contracts.PoolManager.address;
    templateVars.poolManagerStartBlock = v4_Contracts.PoolManager.startBlock;

    if (v4_Contracts.PositionManager) {
        templateVars.positionManagerAddress = v4_Contracts.PositionManager.address;
        templateVars.positionManagerStartBlock = v4_Contracts.PositionManager.startBlock;
    }

try {
    const subgraphFileOut = join(
        fileURLToPath(dirname(import.meta.url)),
        "../subgraph.yaml",
    );
    if (existsSync(subgraphFileOut)) rmSync(subgraphFileOut);
    writeFileSync(
        subgraphFileOut,
        Mustache.render(
            readFileSync(
                join(
                    fileURLToPath(dirname(import.meta.url)),
                    "../subgraph.template.mustache",
                ),
            ).toString(),
            templateVars,
        ),
    );
    console.log("Subgraph file successfully generated.");
} catch (error) {
    console.error("Error while generating subgraph file", error);
    process.exit(1);
}

exec("pnpm format");
